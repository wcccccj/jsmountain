# npm、yarn和pnpm的区别

## 为了解决什么东西
### npm
npm解决了自动化软件安装、配置和卸载，是第一代的包管理器（2010 年 1 月）
在npm3以前npm采用的是嵌套的 node_modules 结构，会造成`依赖地狱`。

为了将嵌套的依赖尽量打平，避免过深的依赖树和包冗余，npm v3 将子依赖「提升」(hoist)，采用扁平的 node_modules 结构，子依赖会尽量平铺安装在主依赖项所在的目录中。这样不会造成大量包的重复安装，依赖的层级也不会太深，解决了依赖地狱问题，但也形成了新的问题。

#### 幽灵依赖
幽灵依赖是指在 package.json 中未定义的依赖，但项目中依然可以正确地被引用到。
如一级依赖也依赖的包，会提升到一级的位置，导致也可以被引用到。
幽灵依赖是由依赖的声明丢失造成的，如果某天某个版本的 A 依赖不再依赖 B 或者 B 的版本发生了变化，那么就会造成依赖缺失或兼容性问题。

#### 不确定性
不确定性是指：同样的 package.json 文件，install 依赖后可能不会得到同样的 node_modules 目录结构。
出现的情况是两个依赖同时依赖了一个库的两个版本，最终会提升后安装的依赖，会出现兼容性的问题。

npm5后也发布了package-lock.json。

#### 依赖分身
不同层级目录安装了相同的依赖，有可能造成同版本依赖重复安装。

### yarn
yarn 也采用扁平化 node_modules 结构，
它的出现是为了解决 npm v3 几个最为迫在眉睫的问题：依赖安装`速度慢，不确定性`。

通过yarn.lock解决不确定性。

没有解决`幽灵依赖和依赖分身问题`。

### pnpm 
不采用扁平化目录结构，采取内容寻址存储，通过`硬链接与符号链接`解决了`幽灵依赖，依赖分身`的问题。
有自己独立的副本，存储源文件，用户可以通过路径引用查找全局store中的源文件，而且这个副本根本不占任何空间。同时，pnpm 会在全局 store 里存储硬链接，不同的项目可以从全局 store 寻找到同一个依赖，大大地节省了磁盘空间。

[软链接]：类似快捷方式，指向指针的指针。软链接的本质是一个特殊的文件，它的内容是指向另一个文件或目录的路径，保存的是它指向文件的全路径， 访问时会替换成绝对路径
[硬链接]：类似指针。删除一个指针不会导致文件删除，所以指针都删除文件才是真正删除。


引用：[深入浅出 npm & yarn & pnpm 包管理机制](https://zhuanlan.zhihu.com/p/526257537)